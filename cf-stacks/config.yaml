AWSTemplateFormatVersion: "2010-09-09"
# Version 1.0 - Initial version, includes Cost tag, Backup Tag
# Version 1.1 - Fixing initial template
# Version 1.2 - Add Mandatory Tags for patching
# Version 1.3 - Add Jira Automation
# Version 1.3.1 - Fix error in patching rule definition
# Version 1.3.2 - Remove noEcho from Jira Password
# Version 1.3.3 - Remove Network Interface from Cost Rule
# Version 1.3.4 - Remove Route Table, Security Group and Network Acl from Cost Rule
# Version 1.3.5 - Remove Cost Rule from ApiStore, OpenShift, Students, Sandbox Increase the number of retries for jira to 10
# Version 1.3.6 - Remove Patching From OpenShift Account
# Version 1.3.7 - Fixing auto remediation on/off
# Version 1.3.8 - Remove Certificate from Costing config
# Version 1.4 - Add Metadata
# Version 1.5 - Added Remediation SSM document and CreateJiraIssue lambda function. Moved the remediation Configuration to an external template 'RemediationConfig.yaml'
# Version 1.5.1 - Moved all roles within this CF to the Roles CF script. Added a list of tags that was already applied to the jira ticket. 
# Version 1.6 - Switch the parameter that contain sensitive info to use value from SSM Parameter store and enable Auto remediation for patching. 
# Version 1.6.1 - Add "Lambda Layer" to pin the AWS SDK to a version that includes the "requests" library, for now.
Description: Template to create all required config rules. Version 1.6.1
Metadata:
 AWS::CloudFormation::Interface:
   ParameterGroups:
     - Label:
         default: "Jira"
       Parameters:
         - IsedJiraUrl
         - IsedJiraUserName
         - IsedJiraProject
         - IsedJiraPassword
     - Label:
         default: "The SSM Parameter Name"
       Parameters:
         - SSMParamName
     - Label:
         default: "Costing"
       Parameters:
         - CostTagConfigRuleName
         - IsedCostCentre
         - IsedEnvironment
         - IsedProjectId
     - Label:
         default: "Backup"
       Parameters:
         - BackupTagConfigRuleName
         - IsedBackup
     - Label:
         default: "Patch"
       Parameters:
         - PatchingTagConfigRuleName
         - IsedPatch
     - Label:
         default: "Remediation Configuration Template URL"
       Parameters:
         - RemediationConfigTemplate         
     - Label:
         default: "Account info"
       Parameters:
          - SandboxAccountID
          - SandboxDBAccountID
          - APIStoreAccountID
          - StudentsAccountID
          - OpenShiftAccountID
          - OpenShiftLabAccountID




Conditions:
  IsRemediationOn: !And [!Not [!Equals [ !Ref "AWS::AccountId", !Ref SandboxAccountID ]], !Not [!Equals [ !Ref "AWS::AccountId", !Ref SandboxDBAccountID ]]]
  IsCostRuleOn: !And [
    !Not [!Equals [ !Ref "AWS::AccountId", !Ref APIStoreAccountID ]],
    !Not [!Equals [ !Ref "AWS::AccountId", !Ref OpenShiftAccountID ]],
    !Not [!Equals [ !Ref "AWS::AccountId", !Ref OpenShiftLabAccountID ]],
    !Not [!Equals [ !Ref "AWS::AccountId", !Ref StudentsAccountID ]]]
  IsPatchingRuleOn: !And [
    !Not [!Equals [ !Ref "AWS::AccountId", !Ref OpenShiftAccountID ]],
    !Not [!Equals [ !Ref "AWS::AccountId", !Ref OpenShiftLabAccountID ]]]
Parameters:
  IsedCostCentre:
    Type: String
  IsedProjectId:
    Type: String
  IsedEnvironment:
    Type: String
  IsedBackup:
    Type: String
  IsedPatch:
    Type: String
  IsedJiraProject:
    Type: AWS::SSM::Parameter::Value<String>
    Default: JiraProject
  IsedJiraURL:
    Type: AWS::SSM::Parameter::Value<String>
    Default: JiraURL 
  IsedJiraUser:
    Type: AWS::SSM::Parameter::Value<String>
    Default: JiraUser     
  SSMParamName:
    Type: String
    Default: ised-jira-password
  CostTagConfigRuleName:
    Type: String
    Default: ised-mandatory-tags-cost
  BackupTagConfigRuleName:
    Type: String
    Default: ised-mandatory-tags-backup
  PatchingTagConfigRuleName:
    Type: String
    Default: ised-mandatory-tags-patching
  SandboxAccountID:
    Type: AWS::SSM::Parameter::Value<String>
    Default: AccountIDSandbox
  SandboxDBAccountID:
    Type: AWS::SSM::Parameter::Value<String>
    Default: AccountIDSandboxDB    
  APIStoreAccountID:
    Type: AWS::SSM::Parameter::Value<String>
    Default: AccountIDAPIStore
  StudentsAccountID:
    Type: AWS::SSM::Parameter::Value<String>
    Default: AccountIDStudents   
  OpenShiftAccountID:
    Type: AWS::SSM::Parameter::Value<String>
    Default: AccountIDOpenShift       
  OpenShiftLabAccountID:
    Type: AWS::SSM::Parameter::Value<String>
    Default: AccountIDOpenShiftLab
  S3Templates:
    Type: AWS::SSM::Parameter::Value<String>
    Default: S3Templates 
Resources:
  AWSConfigRuleTagsCost:
    Type: AWS::Config::ConfigRule
    Condition: IsCostRuleOn
    Properties:
      ConfigRuleName: !Ref CostTagConfigRuleName
      Description: Checks whether your resources have the tags that you specify.
      InputParameters:
        tag1Key: ised-cost-centre
        tag1Value: !Ref IsedCostCentre
        tag2Key: ised-project-id
        tag2Value: !Ref IsedProjectId
        tag3Key: ised-environment
        tag3Value: !Ref IsedEnvironment
      Scope:
        ComplianceResourceTypes:
        - AWS::ACM::Certificate
        - AWS::AutoScaling::AutoScalingGroup
        # - AWS::CloudFormation::Stack
        # - AWS::CodeBuild::Project
        - AWS::DynamoDB::Table
        - AWS::EC2::CustomerGateway
        - AWS::EC2::Instance
        - AWS::EC2::InternetGateway
        # - AWS::EC2::NetworkAcl
        # - AWS::EC2::NetworkInterface
        # - AWS::EC2::RouteTable
        # - AWS::EC2::SecurityGroup
        - AWS::EC2::Subnet
        - AWS::EC2::Volume
        - AWS::EC2::VPC
        - AWS::EC2::VPNConnection
        - AWS::EC2::VPNGateway
        - AWS::ElasticLoadBalancing::LoadBalancer
        - AWS::ElasticLoadBalancingV2::LoadBalancer
        - AWS::RDS::DBInstance
        - AWS::RDS::DBSecurityGroup
        - AWS::RDS::DBSnapshot
        - AWS::RDS::DBSubnetGroup
        - AWS::RDS::EventSubscription
        - AWS::Redshift::Cluster
        - AWS::Redshift::ClusterParameterGroup
        - AWS::Redshift::ClusterSecurityGroup
        - AWS::Redshift::ClusterSnapshot
        - AWS::Redshift::ClusterSubnetGroup
        - AWS::S3::Bucket
      Source:
        Owner: AWS
        SourceIdentifier: REQUIRED_TAGS
  AWSConfigRuleTagsBackup:
    Type: AWS::Config::ConfigRule
    Properties:
      ConfigRuleName: !Ref BackupTagConfigRuleName
      Description: Checks whether your resources have the tags that you specify.
      InputParameters:
        tag1Key: ised-backup
        tag1Value: !Ref IsedBackup
      Scope:
        ComplianceResourceTypes:
        - AWS::EC2::Volume
        - AWS::RDS::DBInstance
      Source:
        Owner: AWS
        SourceIdentifier: REQUIRED_TAGS
  AWSConfigRuleTagsPatching:
    Type: AWS::Config::ConfigRule
    Condition: IsPatchingRuleOn
    Properties:
      ConfigRuleName: !Ref PatchingTagConfigRuleName
      Description: Checks whether your resources have the tags that you specify.
      InputParameters:
        tag1Key: Patch Group
        tag1Value: !Ref IsedPatch
      Scope:
        ComplianceResourceTypes:
        - AWS::EC2::Instance
      Source:
        Owner: AWS
        SourceIdentifier: REQUIRED_TAGS

  CreateJiraIssue:
    Properties:
      Code:
        ZipFile: |
          #
          # Copyright 2018 Amazon.com, Inc. or its affiliates. All Rights Reserved.
          #
          # MIT License

          import boto3
          import json
          from botocore.vendored import requests

          def add_priority(issue, priority):
              fields = issue["fields"]
              fields["priority"] = {"name": priority}

          def add_assignee(issue, assignee):
              fields = issue["fields"]
              fields["assignee"] = {"name": assignee}

          def add_due_date(issue, due_date):
              fields = issue["fields"]
              fields["duedate"] = due_date

          def lookup(rid, resource_types):
              def lookup_for_tags(token):
                  clientResourceGroupTag = boto3.client('resourcegroupstaggingapi')
                  response = clientResourceGroupTag.get_resources(
                      PaginationToken=token,
                      ResourcesPerPage=100,
                      ResourceTypeFilters=resource_types
                  )
                  return response
              total_results = []
              response = lookup_for_tags("")
              page_token = ""
              resourceInfo = ""
              while True:
                  total_results += response["ResourceTagMappingList"]
                  page_token = response["PaginationToken"]
                  if page_token == "":
                      break
                  response = lookup_for_tags(page_token)

              for r in total_results:
                  findResult = r["ResourceARN"].find(rid)
                  if findResult != -1:
                      resourceInfo +=  'The resource ARN '+r["ResourceARN"] + '\n'
                      resourceInfo += '\nTags already applied to the resource: \n'
                      for t in r["Tags"]:
                          resourceInfo += 'Key:' + t['Key'] +  ' Value:' + t['Value'] + '\n'
              return resourceInfo

          def handler(event, context):
              client = boto3.client("ssm")
              config_client = boto3.client('config')

              # Get the list of "resource types" this rule applies to
              config_rule_name = event["ConfigRuleName"].strip()
              config_rule = config_client.describe_config_rules(ConfigRuleNames=[config_rule_name])
              config_rule_resource_types = config_rule["ConfigRules"][0]["Scope"]["ComplianceResourceTypes"]
              resource_types = []

              # Resource not supported by "resource groups tagging"
              # see: https://docs.aws.amazon.com/cli/latest/reference/resourcegroupstaggingapi/index.html
              unsupported_resource_types = [
                  "AWS::AutoScaling::AutoScalingGroup",
                  "AWS::ElasticLoadBalancingV2::LoadBalancer",
                  "AWS::S3::Bucket"
              ]

              # Format the "resource type" notation that "AWS Config" notation uses to something
              # that "resource group tagging api" understands...
              # Ex: "AWS::EC2::Volume" to "ec2:volume"
              for config_rule_resource_type in config_rule_resource_types:
                  # "AutoScaling" resource aren't supported by "resource groups tagging" it seems
                  if config_rule_resource_type in unsupported_resource_types:
                      continue

                  resource_types.append(
                      (config_rule_resource_type[5:]  # Remove assumed "AWS::" prefix
                          .replace("::", ":")         # "::" to ":"
                          .lower())                   # lowercase everything
                  )

              ssm_parameter_name = event["SSMParameterName"].strip()

              secret = client.get_parameter(Name=ssm_parameter_name, WithDecryption=True)['Parameter']['Value']

              username = event["JiraUsername"].strip()
              url = event["JiraURL"].strip()
              resourceId = event["IssueDescription"].strip()

              resourceInfoDescrip = lookup(resourceId, resource_types)

              issue = {
                  "fields": {
                      "summary": event["IssueSummary"].strip() + '-' + resourceId,
                      "project": {
                          "key": event["ProjectKey"].strip()
                      },
                      "description": resourceInfoDescrip.strip(),
                      "issuetype": {
                          "name": event["IssueTypeName"].strip()
                      }
                  }
              }

              priority = event["PriorityName"].strip()
              if priority:
                  add_priority(issue, priority)

              assignee = event["AssigneeName"].strip()
              if assignee:
                  add_assignee(issue, assignee)

              due_date = event["DueDate"].strip()
              if due_date:
                  add_due_date(issue, due_date)

              data = json.dumps(issue)

              headers = {'Content-Type':'application/json'}

              response = requests.post('{0}/rest/api/2/issue/'.format(url),
                                       headers=headers,
                                       data=data,
                                       auth=(username, secret))

              if not response.ok:
                  raise Exception("Received error with status code " + str(response.status_code) + " from Jira")
              else:
                  issue_key = (response.json()["key"])
                  return {"IssueKey": issue_key}
      FunctionName: Ised-CreateJiraIssue
      Handler: index.handler
      MemorySize: 128
      Role: !ImportValue ConfigLambdaRole
      Runtime: python2.7
      Timeout: 300
      Layers:
        # From version 1.13.0, the "requests" module is no longer part of the AWS SDK for Python.
        # https://aws.amazon.com/blogs/compute/upcoming-changes-to-the-python-sdk-in-aws-lambda/
        #
        # The best practice is to bundles dependencies though
        # https://docs.aws.amazon.com/lambda/latest/dg/lambda-python-how-to-create-deployment-package.html
        - "arn:aws:lambda:ca-central-1:778625758767:layer:AWSLambda-Python-AWS-SDK:4"
    Type: AWS::Lambda::Function

  
  CreateSSMDocumentCreateJiraIssue:
    Type: AWS::SSM::Document
    Properties:
      Content: 
        description: "Automation Document Example JSON Template"
        schemaVersion: "0.3"
        assumeRole: "{{ AutomationAssumeRole }}"
        parameters:
          ConfigRuleName:
            type: "String"
            description: "(Required) The config rule name."
          JiraUsername:
            type: "String"
            description: "(Required) The name of the user the issue will be created with."
          SSMParameterName:
            type: "String"
            description: "(Required) The name of an encrypted SSM Parameter containing the API key or password for the Jira user."
          JiraURL:
            type: "String"
            description: "(Required) The url of the Jira instance."
          ProjectKey:
            type: "String"
            description: "(Required) The key of the project the issue should be created in."
          IssueSummary:
            type: "String"
            description: "(Required) A brief summary of the issue."
          IssueDescription:
            type: "String"
            description: "(Required) A detailed description of the issue."
          IssueTypeName:
            type: "String"
            description: "(Required) The name of the type of issue you want to create (ex. Task, Sub-task, Bug, etc)."
          PriorityName:
            type: "String"
            description: "(Optional) The name of the priority of the issue."
            default: ""
          AssigneeName:
            type: "String"
            description: "(Optional) The username of the person the issue should be assigned to."
            default: ""
          DueDate:
            type: "String"
            description: "(Optional) The due date for the issue in yyyy-mm-dd format."
            default: ""
          LambdaAssumeRole:
            type: "String"
            description: "(Optional) The ARN of the role that allows Lambda created by Automation to perform the actions on your behalf. If not specified a transient role will be created to execute the Lambda function."
            default: ""
          AutomationAssumeRole:
            type: "String"
            description: "(Optional) The ARN of the role that allows Automation to perform\
              \ the actions on your behalf. "
            default: ""
        mainSteps:
        - name: "createJiraIssue"
          action: "aws:invokeLambdaFunction"
          inputs:
            FunctionName: "Ised-CreateJiraIssue"
            Payload: "{\"ConfigRuleName\": \"{{ConfigRuleName}}\", \"JiraUsername\": \"{{JiraUsername}}\"\
              , \"SSMParameterName\": \"{{SSMParameterName}}\"\
              , \"JiraURL\": \"{{JiraURL}}\", \"ProjectKey\": \"{{ProjectKey}}\", \"IssueSummary\"\
              : \"{{IssueSummary}}\", \"IssueDescription\": \"{{IssueDescription}}\", \"IssueTypeName\"\
              : \"{{IssueTypeName}}\", \"PriorityName\": \"{{PriorityName}}\", \"AssigneeName\"\
              : \"{{AssigneeName}}\", \"DueDate\": \"{{DueDate}}\"}"
        outputs:
        - "createJiraIssue.Payload"
          
      DocumentType: Automation

  BasicRemediationConfigurationTagsCost:
    Type: AWS::CloudFormation::Stack
    Condition: IsCostRuleOn
    Properties:
      TemplateURL: !Join [ '', [!Ref S3Templates, "config-remediation.yaml" ]]
      Parameters:
        AutomationRoleArm: !ImportValue AutomationRole
        ConfigRuleName: !Ref AWSConfigRuleTagsCost
        IsRemediationAutoOn: !If [IsRemediationOn,'true','false']
        IsedJiraProject: !Ref IsedJiraProject
        IsedJiraUrl: !Ref IsedJiraURL
        IsedJiraUserName: !Ref IsedJiraUser
        IsedLambdaRole: !ImportValue ConfigLambdaRole
        SSMDocumentCreateJiraIssue: !Ref CreateSSMDocumentCreateJiraIssue
        JiraSSMParameterName: !Ref SSMParamName

  BasicRemediationConfigurationTagsBackup:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: !Join [ '', [!Ref S3Templates, "config-remediation.yaml" ]]
      Parameters:
        AutomationRoleArm: !ImportValue AutomationRole
        ConfigRuleName: !Ref AWSConfigRuleTagsBackup
        IsRemediationAutoOn: !If [IsRemediationOn,'true','false']
        IsedJiraProject: !Ref IsedJiraProject
        IsedJiraUrl: !Ref IsedJiraURL
        IsedJiraUserName: !Ref IsedJiraUser
        IsedLambdaRole: !ImportValue ConfigLambdaRole
        SSMDocumentCreateJiraIssue: !Ref CreateSSMDocumentCreateJiraIssue
        JiraSSMParameterName: !Ref SSMParamName
  
  BasicRemediationConfigurationTagsPatching:
    Type: AWS::CloudFormation::Stack
    Condition: IsPatchingRuleOn
    Properties:
      TemplateURL: !Join [ '', [!Ref S3Templates, "config-remediation.yaml" ]]
      Parameters:
        AutomationRoleArm: !ImportValue AutomationRole
        ConfigRuleName: !Ref AWSConfigRuleTagsPatching
        IsRemediationAutoOn: !If [IsRemediationOn,'true','false']
        IsedJiraProject: !Ref IsedJiraProject
        IsedJiraUrl: !Ref IsedJiraURL
        IsedJiraUserName: !Ref IsedJiraUser
        IsedLambdaRole: !ImportValue ConfigLambdaRole
        SSMDocumentCreateJiraIssue: !Ref CreateSSMDocumentCreateJiraIssue
        JiraSSMParameterName: !Ref SSMParamName 
